# -*- coding: utf-8 -*-
"""Predict_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11rseARGRanjnyNjg7SH65jYMsP09AeFo
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

from google.colab import drive
drive.mount('/content/drive')

class LinearModel:
    def __init__(self, num_features):
        self.num_features = num_features
        self.W = np.random.randn(num_features, 1)
        self.b = np.random.randn()
        
    def forward_pass(self, X):
        y = self.b + np.dot(X, self.W)
        return y
    
    def compute_loss(self, y, y_true):
        loss = np.sum(np.square(y - y_true))
        return loss/(2*y.shape[0])
    
    def backward_pass(self, X, y_true, y_hat):
        m = y_hat.shape[0]
        db = np.sum(y_hat - y_true)/m
        dW = np.sum(np.dot(np.transpose(y_hat - y_true), X), axis=0)/m
        return dW, db
    
    def update_params(self, dW, db, lr):
        self.W = self.W - lr * np.reshape(dW, (self.num_features, 1))
        self.b = self.b - lr * db
        
    def train(self, x_train, y_train, iterations, lr):
        losses = []
        for i in range(iterations):
            y_hat = self.forward_pass(x_train)
            dW, db = self.backward_pass(x_train, y_train, y_hat)
            self.update_params(dW, db, lr)
            loss = self.compute_loss(y_hat, y_train)
            losses.append(loss)
            if i % int(iterations/10) == 0:
                print('Iter: {}, Current loss: {:.4f}'.format(i, loss))
        return losses

    def split_sets(x):
      test_size = int(0.7 * len(x))
      return x[0: test_size], x[test_size:len(x)] # test, train

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('/content/drive/MyDrive/LR/test_scores.csv')
df.drop(['classroom', 'student_id'], axis= 1, inplace= True)
df.loc[(df['school_setting'] == 'Urban') , 'school_setting'] = 0.0
df.loc[(df['school_setting'] == 'Suburban') , 'school_setting'] = 1.0
df.loc[(df['school_setting'] == 'Rural') , 'school_setting'] = 2.0
df.loc[(df['school_type'] == 'Non-public') , 'school_type'] = 0.0
df.loc[(df['school_type'] == 'Public') , 'school_type'] = 1.0
df.loc[(df['teaching_method'] == 'Standard') , 'teaching_method'] = 0.0
df.loc[(df['teaching_method'] == 'Experimental') , 'teaching_method'] = 1.0


df.head()


x1 = df.school_setting.values
x2 = df.school_type.values
x3 = df.teaching_method.values
x4 = df.pretest.values

x = np.array([x1,x2,x3,x4]).transpose()

y = df.posttest.values

y = np.reshape(y, (y.shape[0], 1))

model = LinearModel(4)

x_test, x_train = LinearModel.split_sets(x)
y_test, y_train = LinearModel.split_sets(y)

losses = model.train(x_train, y_train,4000, 0.000001)
print("Loss graph")
plt.plot(losses)
plt.show()



print("Predictions graph")
model.compute_loss(y_preds, y_test)

plt.plot(range(len(y_test)), y_test, 'r.', label='Test', alpha=.5)
plt.plot(range(len(y_test)), y_preds, 'bx', label='Predictions',alpha=.5)
plt.legend()
plt.xlabel('# of instance')
plt.ylabel('Performance')
plt.show()

print("Modelo")
print("y= ",model.W[0],"x1",model.W[1],"x2",model.W[3],"x3" + model.W[4],"x3 ",model.b)

print(model.W, model.b)

print("Tipo de Escuela(Urbana(0)/Suburbana(1)/Rural(2)): ")
TES =  float(input())

print("Tipo de Educacion(Privada(0)/Publica()): ")
TED =  float(input())

print("Metodo de enseñanza(Tradicional(0)/Experimental(1)): ")
ME =  float(input())

print("Calificacion del estudiante: ")
Cal =  float(input())

Calificacion = model.W[0] * TES + model.W[1] * TED + model.W[2] * ME + model.W[3] * Cal + model.b
print("Calificación Calculada: ")
print(Calificacion)